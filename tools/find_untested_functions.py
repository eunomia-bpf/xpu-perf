#!/usr/bin/env python3
"""
Find NVIDIA functions that are traceable but not covered by any test script
"""

import os
import re

# Configuration
TRACEABLE_FUNCTIONS_FILE = "/home/yunwei37/workspace/xpu-perf/tools/nvidia_traceable_functions.txt"
BPFTRACE_SCRIPT_DIR = "/home/yunwei37/workspace/xpu-perf/tools/bpftrace-script"
OUTPUT_FILE = "/home/yunwei37/workspace/xpu-perf/tools/untested_functions.txt"

def load_traceable_functions():
    """Load all traceable functions from the list"""
    functions = set()
    current_module = None

    with open(TRACEABLE_FUNCTIONS_FILE, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            # Check if this is a module header
            if line.startswith('###'):
                current_module = line.strip('#').strip()
                continue

            # Add the function
            functions.add(line)

    print(f"Loaded {len(functions)} traceable functions")
    return functions

def extract_patterns_from_script(script_path):
    """Extract kprobe patterns from a bpftrace script"""
    patterns = []

    with open(script_path, 'r') as f:
        content = f.read()

    # Find kprobe patterns
    # Match patterns like: kprobe:nv_*, kprobe:uvm_channel_*, etc.
    kprobe_matches = re.findall(r'kprobe:([a-zA-Z0-9_*]+)', content)

    for match in kprobe_matches:
        patterns.append(match)

    return patterns

def pattern_matches_function(pattern, function):
    """Check if a wildcard pattern matches a function name"""
    if '*' not in pattern:
        # Exact match
        return pattern == function

    # Convert wildcard pattern to regex
    regex_pattern = pattern.replace('*', '.*')
    regex_pattern = '^' + regex_pattern + '$'

    return re.match(regex_pattern, function) is not None

def get_all_tested_functions(script_dir, traceable_functions):
    """Get all functions covered by test scripts"""
    tested_functions = set()
    patterns_by_script = {}

    # Load all bpftrace scripts
    for filename in os.listdir(script_dir):
        if not filename.endswith('.bt'):
            continue

        script_path = os.path.join(script_dir, filename)
        patterns = extract_patterns_from_script(script_path)
        patterns_by_script[filename] = patterns

        print(f"Script {filename}: {len(patterns)} patterns")

        # Check which functions match these patterns
        for function in traceable_functions:
            for pattern in patterns:
                if pattern_matches_function(pattern, function):
                    tested_functions.add(function)
                    break

    print(f"\nTotal tested functions: {len(tested_functions)}")
    return tested_functions, patterns_by_script

def main():
    print("=" * 80)
    print("Finding Untested NVIDIA Functions")
    print("=" * 80)
    print()

    # Load traceable functions
    traceable_functions = load_traceable_functions()

    # Get tested functions
    tested_functions, patterns_by_script = get_all_tested_functions(
        BPFTRACE_SCRIPT_DIR,
        traceable_functions
    )

    # Find untested functions
    untested_functions = traceable_functions - tested_functions

    print(f"\n{'=' * 80}")
    print(f"RESULTS")
    print(f"{'=' * 80}")
    print(f"Total traceable: {len(traceable_functions)}")
    print(f"Total tested: {len(tested_functions)}")
    print(f"Total untested: {len(untested_functions)}")
    print(f"Coverage: {len(tested_functions) / len(traceable_functions) * 100:.2f}%")

    if untested_functions:
        print(f"\nFound {len(untested_functions)} untested functions")

        # Save detailed results
        with open(OUTPUT_FILE, 'w') as f:
            f.write("# Untested NVIDIA Traceable Functions\n")
            f.write(f"# Generated by find_untested_functions.py\n")
            f.write(f"# Total: {len(untested_functions)} functions\n\n")

            f.write(f"## Summary\n")
            f.write(f"- Total traceable: {len(traceable_functions)}\n")
            f.write(f"- Total tested: {len(tested_functions)}\n")
            f.write(f"- Total untested: {len(untested_functions)}\n")
            f.write(f"- Coverage: {len(tested_functions) / len(traceable_functions) * 100:.2f}%\n\n")

            f.write(f"## Test Script Patterns\n\n")
            for script, patterns in sorted(patterns_by_script.items()):
                f.write(f"### {script}\n")
                for pattern in patterns:
                    f.write(f"  - kprobe:{pattern}\n")
                f.write("\n")

            f.write(f"## All Untested Functions\n\n")
            for func in sorted(untested_functions):
                f.write(f"{func}\n")

        print(f"Detailed results saved to: {OUTPUT_FILE}")

        # Generate two bpftrace scripts
        script_output_1 = "/home/yunwei37/workspace/xpu-perf/tools/bpftrace-script/test_untested_1.bt"
        script_output_2 = "/home/yunwei37/workspace/xpu-perf/tools/bpftrace-script/test_untested_2.bt"
        generate_bpftrace_scripts(untested_functions, script_output_1, script_output_2)
    else:
        print("\nâœ“ All traceable functions are covered by test scripts!")

def generate_bpftrace_scripts(untested_functions, output_file_1, output_file_2):
    """Generate two bpftrace scripts to test all untested functions"""

    all_functions = sorted(untested_functions)
    mid_point = len(all_functions) // 2

    # Split functions into two halves
    functions_1 = all_functions[:mid_point]
    functions_2 = all_functions[mid_point:]

    # Write first script
    with open(output_file_1, 'w') as f:
        f.write("#!/usr/bin/env bpftrace\n")
        f.write("/*\n")
        f.write(" * Test Untested NVIDIA Functions (Part 1/2)\n")
        f.write(" * Auto-generated by find_untested_functions.py\n")
        f.write(f" * Functions: {len(functions_1)}/{len(all_functions)}\n")
        f.write(" */\n\n")

        f.write("BEGIN {\n")
        f.write(f'    printf("Tracing {len(functions_1)} untested NVIDIA functions (Part 1/2)...\\n");\n')
        f.write("}\n\n")

        # Write all functions explicitly
        for i, func in enumerate(functions_1):
            if i == 0:
                f.write(f"kprobe:{func}")
            else:
                f.write(f",\nkprobe:{func}")

        f.write("\n{\n")
        f.write("    @calls[probe] = count();\n")
        f.write("}\n\n")

        f.write("END {\n")
        f.write('    printf("\\n=== Untested Function Calls (Part 1/2) ===\\n");\n')
        f.write("    print(@calls);\n")
        f.write("    clear(@calls);\n")
        f.write("}\n")

    # Write second script
    with open(output_file_2, 'w') as f:
        f.write("#!/usr/bin/env bpftrace\n")
        f.write("/*\n")
        f.write(" * Test Untested NVIDIA Functions (Part 2/2)\n")
        f.write(" * Auto-generated by find_untested_functions.py\n")
        f.write(f" * Functions: {len(functions_2)}/{len(all_functions)}\n")
        f.write(" */\n\n")

        f.write("BEGIN {\n")
        f.write(f'    printf("Tracing {len(functions_2)} untested NVIDIA functions (Part 2/2)...\\n");\n')
        f.write("}\n\n")

        # Write all functions explicitly
        for i, func in enumerate(functions_2):
            if i == 0:
                f.write(f"kprobe:{func}")
            else:
                f.write(f",\nkprobe:{func}")

        f.write("\n{\n")
        f.write("    @calls[probe] = count();\n")
        f.write("}\n\n")

        f.write("END {\n")
        f.write('    printf("\\n=== Untested Function Calls (Part 2/2) ===\\n");\n')
        f.write("    print(@calls);\n")
        f.write("    clear(@calls);\n")
        f.write("}\n")

    print(f"Generated bpftrace scripts:")
    print(f"  Part 1: {output_file_1} ({len(functions_1)} functions)")
    print(f"  Part 2: {output_file_2} ({len(functions_2)} functions)")
    print(f"  Total: {len(all_functions)} functions")

if __name__ == '__main__':
    main()
