# PC Sampling Data Visualization Guide

## Overview
This guide explains how to visualize and analyze PC sampling data files (`.dat` format) generated by the `libpc_sampling_continuous.so` library.

## Tool: pc_sampling_utility

The CUDA CUPTI SDK includes a utility tool specifically designed to parse and visualize PC sampling data files.

### Location
```bash
/usr/local/cuda-12.9/extras/CUPTI/samples/pc_sampling_utility/pc_sampling_utility
```

### Building the Utility
```bash
cd /usr/local/cuda-12.9/extras/CUPTI/samples/pc_sampling_utility
make
```

## Basic Usage

### 1. View PC Sampling Data
```bash
/usr/local/cuda-12.9/extras/CUPTI/samples/pc_sampling_utility/pc_sampling_utility \
  --file-name /path/to/your_data.dat
```

### 2. Available Options
```
--help                            : Displays help message
--file-name                       : Name of the file to parse and print data
--disable-merge                   : Disable merge of buffers
--disable-pc-info-prints          : Disable PC records info prints
--disable-source-correlation      : Disable Source correlation
--verbose                         : Enable verbose prints
```

## Understanding the Output

### Sample Output Format
```
========================== PC Records Buffer Info ==========================
Buffer Number: 1, Range Id: 1, Count of PC records: 11, Total Samples: 102

functionName: _Z9vectorAddPKfS0_Pfi
correlationId: 1
pcOffset: 272
stallReasonCount: 2
smsp__pcsamp_warps_issue_stalled_long_scoreboard: 39
smsp__pcsamp_warps_issue_stalled_long_scoreboard_not_issued: 39
```

### Key Metrics Explained

#### Buffer Info
- **Buffer Number**: Sequential buffer identifier
- **Range Id**: Sampling range identifier (correlates to kernel launches in serialized mode)
- **Count of PC records**: Number of unique program counter locations sampled
- **Total Samples**: Total number of samples collected in this buffer

#### PC Record Details
- **functionName**: Demangled CUDA kernel function name
- **correlationId**: Correlation ID linking to kernel launch
- **pcOffset**: Program counter offset within the function
- **lineNumber**: Source code line (requires cubin files for correlation)
- **fileName**: Source file name (requires cubin files for correlation)

#### Stall Reasons (Performance Bottlenecks)

Common stall reasons you'll see:

1. **smsp__pcsamp_warps_issue_stalled_long_scoreboard**
   - Warps stalled waiting for long-latency operations (memory, texture fetches)
   - **Action**: Optimize memory access patterns, use shared memory

2. **smsp__pcsamp_warps_issue_stalled_short_scoreboard**
   - Warps stalled waiting for arithmetic operations
   - **Action**: Reduce register dependencies, improve ILP

3. **smsp__pcsamp_warps_issue_stalled_imc_miss**
   - Instruction cache misses
   - **Action**: Reduce code size, improve instruction locality

4. **smsp__pcsamp_warps_issue_stalled_wait**
   - Warps waiting on barriers or dependencies
   - **Action**: Reduce synchronization, optimize work distribution

5. **smsp__pcsamp_warps_issue_stalled_drain**
   - Pipeline drain (end of kernel execution)
   - **Info**: Normal overhead at kernel completion

6. **smsp__pcsamp_warps_issue_stalled_mio_throttle**
   - Memory I/O throttling
   - **Action**: Reduce memory bandwidth pressure

7. **smsp__pcsamp_warps_issue_stalled_no_instructions**
   - No instructions ready to issue
   - **Action**: Increase ILP, improve instruction scheduling

## Advanced Usage: Source Correlation

To correlate PC samples with CUDA source code, you need cubin files.

### Step 1: Extract Cubin Files
```bash
# Extract all cubin files from your executable
cuobjdump -xelf all /path/to/your_executable

# This creates files like: 1.sm_90.cubin, 2.sm_90.cubin, etc.
```

### Step 2: Rename Cubin Files
```bash
# Rename to the format expected by pc_sampling_utility
mv 1.sm_90.cubin 1.cubin
mv 2.sm_90.cubin 2.cubin
# etc.
```

### Step 3: Run with Source Correlation
```bash
# Place cubin files in the same directory as the utility
cd /usr/local/cuda-12.9/extras/CUPTI/samples/pc_sampling_utility/

# Run the utility (it will automatically find .cubin files)
./pc_sampling_utility --file-name /path/to/your_data.dat
```

With cubins, the output will show:
```
functionName: _Z9vectorAddPKfS0_Pfi
pcOffset: 272
lineNumber: 45              <-- Source line number
fileName: vectorAdd.cu      <-- Source file name
dirName: /home/user/src/    <-- Source directory
```

## Example: Analyzing vectorAdd Performance

```bash
# Generate sampling data
export LD_LIBRARY_PATH=/root/xpu-perf/documents/pc_sampling_start_stop:/root/xpu-perf/lib64:/usr/local/cuda/lib64:$LD_LIBRARY_PATH
./libpc_sampling_continuous.pl --app "./vectorAdd" --file-name vector_test.dat

# Visualize the results
/usr/local/cuda-12.9/extras/CUPTI/samples/pc_sampling_utility/pc_sampling_utility \
  --file-name 1_vector_test.dat
```

### Sample Analysis Output

For the vectorAdd kernel:
- **pcOffset: 272** - 39 samples with `long_scoreboard` stalls
  - Indicates memory latency bottleneck
  - Suggestion: Use shared memory or improve coalescing

- **pcOffset: 80** - 15 samples with `imc_miss` stalls
  - Instruction cache misses
  - Suggestion: Reduce code complexity

- **pcOffset: 192** - 15 samples with `short_scoreboard` stalls
  - Arithmetic dependencies
  - Suggestion: Increase instruction-level parallelism

## Visualization Workflow

```
┌─────────────────────────────────────────────────────────────┐
│  1. Generate PC Sampling Data                               │
│     └─> Use libpc_sampling_continuous.pl or CUDA_INJECTION  │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Parse with pc_sampling_utility                          │
│     └─> Identifies hotspots and stall reasons               │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Optional: Add Source Correlation                        │
│     └─> Extract cubins for line-level attribution           │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Analyze Performance Bottlenecks                         │
│     └─> Focus on highest sample counts                      │
└─────────────────────────────────────────────────────────────┘
```

## Tips for Effective Analysis

1. **Focus on High Sample Counts**: PC offsets with the most samples are your hotspots
2. **Check Stall Reason Distribution**: Different stalls require different optimizations
3. **Compare Across Launches**: In serialized mode, each correlationId is a separate kernel launch
4. **Use Source Correlation**: Makes it much easier to identify which code needs optimization
5. **Monitor Dropped Samples**: If non-zero, increase buffer sizes

## Quick Reference

### Generate Data
```bash
./libpc_sampling_continuous.pl --app "your_app" --file-name output.dat
```

### Visualize
```bash
/usr/local/cuda-12.9/extras/CUPTI/samples/pc_sampling_utility/pc_sampling_utility --file-name 1_output.dat
```

### With Source Correlation
```bash
cuobjdump -xelf all your_app
mv *.sm_*.cubin *.cubin  # Rename appropriately
./pc_sampling_utility --file-name 1_output.dat
```

## See Also
- CUPTI PC Sampling API Documentation
- NVIDIA Nsight Compute (alternative GUI-based profiler)
- CUDA Profiling Best Practices Guide
